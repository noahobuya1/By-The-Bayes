---
title: "By the Bayes (STA240 Project)"
author: "Noah Obuya & Tamya Davidson"
date: "2024-05-01"
output:
  pdf_document:
    keep_tex: yes
    latex_engine: xelatex
  html_document: default
---

```{r initializing, echo=FALSE, warning=FALSE, message=FALSE}

library(tidyverse)
library(knitr)

```

# Proposal

## Introduction

Welcome to By the Bayes! A restaurant serving food straight from the Louisiana Bayou. What makes our restaurant special is that every step of our process is backed by probabilistic modeling and inference. It's in our name. Today we'll be taking you through the customer's queuing experience in two different scenarios, providing simulations and explanations to back all of our claims.

## Analysis Plan

### Scenario One

Our first scenario models simple setting with one dining table and one chef, with operating hours 10am - 10pm. Suppose customers arrive according to a Poisson process with a rate of

$$
 \lambda_A = 5 \ \text{{per hour}} , \ \text{40 total customers from open to close}
$$

Once a customer arrives, their total service time (ordering, cooking and eating) can be modeled by an exponential distribution with rate λS = 6.

$$
 \lambda_S = 6 
$$

To get a sense of the customer queuing experience, we will run multiple simulations of our exponential distribution. The simulation will model the time it takes to service one customer. Essentially, once one customer comes in, we want to know how long it takes for another customer to be serviced. We only have one table and one chef, so we are only able to handle one customer at a time. We will build upon the exponential distribution, providing two models, as we continue to model its efficacy.

### Scenario Two

Our second scenario gives us 5 dining tables and $$L$$ chefs, with operating hours 10am - 10pm. Customers arrive according to a Poisson process with a rate of

$$
 \lambda_A = 10 \ \text{{per hour}} , \ \text{80 total customers from open to close}
$$

Once a customer arrives, their total service time can be modeled by an exponential distribution with rate λS = 3L. Each additional chef cuts down the wait time by $\frac 13$.

$$
 \lambda_S = 3L
$$

We are assuming a customer spends \$50 per meal, and that each chef earns a wage of \$40 per hour.

To simulate this scenario, we will build upon the model we created in Scenario One. The main differences being an increase in tables, and the addition of an input variable (number of chefs). To better model the more sophisticated scenario, we will be using the queuing library in R-Studio. The queueing library in R is a package designed to help users model and analyze different types of queueing systems, which are scenarios where tasks, items, or people wait in line to be processed or served. In other words, it helps you understand and simulate situations similar to lines at a grocery store, calls waiting to be answered at a call center, or our very own probabilistic model!

Queueing theory uses a variety of models to describe different systems, and one common way to describe these models is with Kendall's notation (M/M/c). The first M stands for Markovian, meaning memoryless and random, the second M stands for the wait in between service times being modeled by an exponential distribution and the c stands for the amount of servers. In our first model, our Kendall notation would have looked like $M/M/1$ because we only had one server, or in our case, chef. In this model, our c remains a variable because we are trying to find out the best number of chefs to maintain.

After running a simulation using queuing theory, we will create a function that, when given the input of chef number, returns to us average wait time, revenue, wages and of course, profits. This final table will allow us to make a decision on how many chefs we should hire.

# Analysis

## Scenario One

#### Part One - The Mean

```{r meanwaittime plot, echo=FALSE, warning=FALSE, message=FALSE, fig.width=4, fig.height=3}


lambda_s1 <- 6

x <- seq(0, 1, length.out = 1000)
y <- dexp(x, rate = lambda_s1)

meanwaitingtime <- data.frame(x = x, y = y)

p <- ggplot(meanwaitingtime, aes(x = x, y = y)) +
  geom_line() +
  geom_vline(aes(xintercept = 1/lambda_s1), linetype = "dashed", color = "red") +
  annotate("text", x = 1/lambda_s1, y = max(meanwaitingtime$y)/2, label = "Mean waiting time", hjust = -0.1, color = "red") +
  labs(x = "Waiting time", y = "Density", title = "Exponential distribution with lambda = 6")

p


```

Figure 1 allows us to explain our mean wait time. Given the PDF (Probability Density Function) of our model, we see that the average wait time is 1/6 of an hour, or 10 minutes. This can also be described by $$1/ \lambda$$, once again giving us 1/6 of an hour.

Figure 1 showcases the probability density function (PDF) for our basic queuing model's wait times, characterized by an exponential distribution with a mean wait time of $\frac{1}{\lambda} = \frac{1}{6}$ hours, or approximately 10 minutes. This simple model assumes a constant service rate and a single service channel, making it particularly suited for initial planning stages.

However, the exponential distribution's memorylessness property — where the probability of service completion is constant regardless of how long a customer has already waited — does not always align with practical service scenarios. In reality, customer arrivals can be highly variable, and during periods of high demand, this variability can lead to significantly longer wait times than our model suggests.

From the graph, we observe that while many customers may experience wait times close to the mean, a substantial variation is possible, indicative of the potential for both shorter and unexpectedly longer waits. Such insights are crucial for managing customer expectations and improving service delivery strategies. They highlight the need for employing more comprehensive models like the M/M/c system in settings where multiple service points or varied service rates play a critical role in daily operations.

#### Part Two - First Scenario One Simulation


For our first model, we decided to look at the start and end times of each customer's service. The weight time is calculated by the difference between their service start time and their service end time.

```{r s1simulation1, echo=FALSE, warning=FALSE, message=FALSE}

set.seed(1)

lambda_A <- 5 
lambda_S <- 6
num_customers <- 1000
num_simulations <- 3

run_simulation <- function() {
  arrival_times <- cumsum(rexp(num_customers, rate=lambda_A))
  service_start_times <- pmax(arrival_times, cummax(arrival_times[-1] + rexp(num_customers-1, rate=lambda_S)))
  service_end_times <- service_start_times + rexp(num_customers, rate=lambda_S)
  wait_times <- service_start_times - arrival_times
  return(mean(wait_times))
}

average_wait_times <- replicate(num_simulations, run_simulation())

average_wait_times_df <- data.frame(
  Simulation_Run = 1:num_simulations,
  Average_Wait_Time_hours = average_wait_times,
  Average_Wait_Time_minutes = average_wait_times * 60 
)


overall_average <- mean(average_wait_times)
average_wait_times_df <- rbind(average_wait_times_df, c("Average", overall_average, overall_average * 60))


names(average_wait_times_df)[1] <- "Simulation Run"
names(average_wait_times_df)[2] <- "Average Wait Time (hours)"
names(average_wait_times_df)[3] <- "Average Wait Time (minutes)"


knitr::kable(average_wait_times_df, format = "markdown", caption = "Average Wait Times for Each Simulation Run")





```

The initial simulation attempts to model a single-server queue system where each customer's service and wait time are determined based on exponential distributions for arrivals and services. It assumes random arrivals and service times but lacks detailed dynamics such as the server's operational status (idle or busy) and does not track the length of the queue. This simplistic approach provides basic insights but overlooks several aspects of real-world service environments.

We can demonstrate that this model is missing the mark through observing our means for the queuing simulation

Mean Wait Time in the System (including service time):
$$W = \frac{1}{\mu - \lambda}$$
Mean Wait Time in the Queue (excluding service time):
$$W_q = \frac{\rho}{\mu - \lambda}$$
where $$ \rho = \frac{\lambda}{\mu} $$ represents the server utilization, server utilization being the amount of time a server is "busy". Caculating our two means we get:

$$W = 60 \ minutes$$ and $$W_q = 50 \ minutes$$

So, clearly, our model is incorrectly averaging means, because it finds that customers are only waiting for an average of 25 minutes ($W = 25 \ minutes$)

This model needs to improve by incorporating more realistic customer behaviors and queue dynamics. Enhancements such as considering customer balking or reneging, and providing metrics for queue length and server utilization, would offer a more comprehensive understanding. Additionally, incorporating variability in arrival and service rates to reflect different operational conditions like peak hours would make the simulation more robust.

### Part Three - Second Scenario One Simulation

```{r s1simulation2, echo=FALSE, warning=FALSE, message=FALSE}

set.seed(2)  

lambda_A <- 5  
lambda_S <- 6  
num_customers <- 1000
num_simulations <- 3

run_simulation <- function() {
  arrival_times <- cumsum(rexp(num_customers, rate=lambda_A))
  service_start_times <- numeric(num_customers)
  service_end_times <- numeric(num_customers)
  
  service_start_times[1] <- arrival_times[1]
  service_end_times[1] <- service_start_times[1] + rexp(1, rate=lambda_S)
  
  for (i in 2:num_customers) {
    service_start_times[i] <- max(arrival_times[i], service_end_times[i-1])
    service_end_times[i] <- service_start_times[i] + rexp(1, rate=lambda_S)
  }
  
  wait_times <- service_start_times - arrival_times
  return(mean(wait_times))
}

average_wait_times <- replicate(num_simulations, run_simulation())

average_wait_times_df <- data.frame(
  "Simulation Run" = 1:num_simulations,
  "Average Wait Time (hours)" = average_wait_times,
  "Average Wait Time (minutes)" = average_wait_times * 60  
)

overall_average <- mean(average_wait_times)
average_wait_times_df <- rbind(average_wait_times_df, c("Average", overall_average, overall_average * 60))

names(average_wait_times_df)[1] <- "Simulation Run"
names(average_wait_times_df)[2] <- "Average Wait Time (hours)"
names(average_wait_times_df)[3] <- "Average Wait Time (minutes)"

knitr::kable(average_wait_times_df, format = "markdown", caption = "Average Wait Times Improved Simulation")


```

As we can see, the improved simulation averages much closer to the true mean wait time of $W = 60 \ minutes$. The revised simulation significantly improves upon the first by explicitly calculating the waiting times for each customer, considering the time until the previous customer's service is complete. This approach more accurately reflects actual queue dynamics, where service cannot begin until the previous service has concluded, thus providing a realistic measure of waiting times. Each customer's start time is dynamically adjusted based on the service end time of the preceding customer, which prevents any overlap and simulates a true first-come, first-served queue.

This methodology provides deeper insights into how service efficiency impacts customer waiting experiences, making it a valuable tool for operational planning and optimization. Further improvements could include multi-server configurations, which is what we will tackle next, in Scenario Two.

### Scenario Two

In Scenario 2, we used the queueing model package from R. The package allowed us to calculate performance measures such as the average number of customers in the system, the average waiting time, the utilization of servers, and the probability of having a certain number of customers in the system. By simulating different scenarios with varying numbers of chefs (L), we can determine the optimal number of chefs to minimize wait times and maximize profits. The package also allowed us to evaluate the impact of different factors, such as customer arrival rates and service times, on the restaurant's performance.

```{r Wait Times and Tables}

library(queueing)

simulate_day <- function(L) {
  lambda_A <- 10  # Arrival rate (customers per hour)
  num_tables <- 5  # Number of dining tables
  lambda_S <- 3 * L  # Service rate per hour based on number of chefs

  # M/M/c model where c = number of tables
  # and the service rate is adjusted based on the number of chefs
  Q_mm_c <- NewInput.MMC(lambda = lambda_A, mu = lambda_S, c = num_tables, n = 1000)
  result <- QueueingModel(Q_mm_c)
  
  # Extract average wait time in the queue (time spent waiting for a table)
  avg_wait_time <- result$Lq / lambda_A * 60  # Convert hours to minutes
  
  return(list(avg_wait_time = avg_wait_time, utilization = result$U))
}

# Testing with different number of chefs
simulate_day(2)
simulate_day(1)

```

The model above uses a queueing system for our restaurant with a varying number of chefs LL. It uses the M/M/c queueing model, where:

-   λAλA​ is the arrival rate of customers (10 customers per hour),

-   **`num_tables`** is the number of dining tables (5 tables),

-   λSλS​ is the service rate per hour, which is calculated as 3×L3×L based on the number of chefs.

    By simulating the queueing system with different numbers of chefs, the model helps determine the optimal number of chefs to minimize customer wait times and maximize profits.

```{r Optimal Chefs}

library(queueing)

# Function to simulate one day's operation and calculate profits
simulate_day <- function(L) {
  lambda_A <- 10  # Arrival rate (customers per hour)
  num_tables <- 5  # Number of dining tables
  lambda_S <- 3 * L  # Service rate per hour based on number of chefs
  opening_hour <- 10  # Restaurant opening hour
  closing_hour <- 22  # Restaurant closing hour

  # Using M/M/c queue model
  Q_mm_c <- NewInput.MMC(lambda = lambda_A, mu = lambda_S, c = num_tables, n = 1000)
  result <- QueueingModel(Q_mm_c)

  # Calculate hourly revenue based on the minimum of customer arrivals or table capacity
  hourly_revenue <- min(lambda_A, lambda_S * num_tables) * 50  # $50 per customer
  daily_revenue <- hourly_revenue * (closing_hour - opening_hour)  # Calculate hours of operation

  # Calculate daily wages for chefs
  daily_wages <- L * 40 * (closing_hour - opening_hour)  # $40 per hour per chef

  # Calculate profits
  profits <- daily_revenue - daily_wages

  # Get average wait time in minutes
  avg_wait_time <- result$Lq / lambda_A * 60

  return(list(profits = profits, avg_wait_time = avg_wait_time, revenue = daily_revenue, wages = daily_wages))
}

# Function to find optimal number of chefs
optimize_chefs <- function(max_chefs = 10) {
  results <- data.frame(Chefs = integer(), Profits = numeric(), AvgWaitTime = numeric(), Revenue = numeric(), Wages = numeric())
  
  for (L in 1:max_chefs) {
    sim_results <- simulate_day(L)
    results[nrow(results) + 1, ] <- c(L, sim_results$profits, sim_results$avg_wait_time, sim_results$revenue, sim_results$wages)
  }
  
  optimal_chefs <- results[which.max(results$Profits), ]
  return(list(optimal = optimal_chefs, details = results))
}

# Execute the optimization function and print results
optimization_results <- optimize_chefs()
print(optimization_results$details)
cat("Optimal number of chefs for maximum profits:", optimization_results$optimal$Chefs, "\n")




```

This model simulates the daily operation of a restaurant to determine the optimal number of chefs that maximize profits while considering customer wait times. By varying the number of chefs, the model calculates the restaurant's revenue, chef wages, and profits for each scenario. It uses the M/M/c queuing model to simulate customer arrivals, service times, and queue lengths. The model then identifies the number of chefs that results in the highest profits.

## Discussions & Limitations

## Conclusion

## References

#### Lab 10

Rossetti, R. (2024, April 4). Sakai.duke.edu. <https://sakai.duke.edu/access/content/group/2e691ccc-405a-4982-bf81-42137192402e/Labs/lab10_sol.html>

#### Simulation of Exponential Distribution using R

Hernández, C. (2020, September 29). Simulation of Exponential Distribution using R. RPubs. <https://rpubs.com/carlosehernandezr/Exponential-Distribution#>:\~:text=The%20exponential%20distribution%20can%20be,deviation%20is%20also%201%2Flambda
