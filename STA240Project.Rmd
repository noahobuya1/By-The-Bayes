---
title: "By the Bayes (STA240 Project)"
author: "Noah Obuya & Tamya Davidson"
date: "2024-05-01"
output: html_document
---

```{r intitializing}

library(tidyverse)

```

# Proposal

## Introduction

Welcome to By the Bayes! A restaurant serving food straight from the Louisiana Bayou. What makes our restaurant special is that every step of our process is backed by probabilistic modeling and inference. It's in our name. Today we'll be taking you through the customer's queuing experience in two different scenarios, providing simulations and explanations to back all of our claims.

## Analysis Plan

#### Scenario One

Our first scenario models simple setting with one dining table and one chef, with operating hours 10am - 10pm. Suppose customers arrive according to a Poisson process with a rate of λA = 5 per hour.

$$
 \lambda_A = 5 \ \text{{per hour}} , \ \text{40 total customers from open to close}
$$

Once a customer arrives, their total service time (ordering, cooking and eating) can be modeled by an exponential distribution with rate λS = 6.

$$
 \lambda_S = 6 
$$

To get a sense of the customer queuing experience, we will run multiple simulations of our exponential distribution. The simulation will model the time it takes to service one customer. Essentially, once one customer comes in, we want to know how long it takes for another customer to be serviced. We only have one table and one chef, so we are only able to handle one customer at a time. We will build upon the exponential distribution simulation to create an algorithm that lets us know whether a not a table is ready for a customer.

To analyze the customer's queueing experience, set the average number of customers in the system = (L), the average number of customers waiting in line = (Lq), the average time a customer spends in the system = (W), and the average time a customer spends waiting in line = (Wq).

(L):represents the average number of customers, including those being served and those waiting in line. In this scenario, we can use the formula for an M/M/1 queue to calculate L: L= λa/ μ−λa

#### Scenario Two

## References

#### Lab 10

Rossetti, R. (2024, April 4). Sakai.duke.edu. <https://sakai.duke.edu/access/content/group/2e691ccc-405a-4982-bf81-42137192402e/Labs/lab10_sol.html>

#### Simulation of Exponential Distribution using R

Hernández, C. (2020, September 29). Simulation of Exponential Distribution using R. RPubs. <https://rpubs.com/carlosehernandezr/Exponential-Distribution#>:\~:text=The%20exponential%20distribution%20can%20be,deviation%20is%20also%201%2Flambda

# Analysis

## Scenario One

#### Part One - The Mean

```{r meanwaittime plot}


lambda_s1 <- 6

x <- seq(0, 1, length.out = 1000)
y <- dexp(x, rate = lambda_s1)

meanwaitingtime <- data.frame(x = x, y = y)

p <- ggplot(meanwaitingtime, aes(x = x, y = y)) +
  geom_line() +
  geom_vline(aes(xintercept = 1/lambda_s1), linetype = "dashed", color = "red") +
  annotate("text", x = 1/lambda_s1, y = max(meanwaitingtime$y)/2, label = "Mean waiting time", hjust = -0.1, color = "red") +
  labs(x = "Waiting time", y = "Density", title = "Exponential distribution with λ = 6")


```

Figure 1 allows us to explain our mean wait time. Given the PDF (Probability Density Function) of our model, we see that the average wait time is 1/6 of an hour, or 10 minutes. This can also be described by $$1/ \lambda$$, once again giving us 1/6 of an hour.

#### Part Two - The Exponential Simulation without accounting for a Que

```{r}

lambda_A <- 5  # Arrival rate per hour
lambda_S <- 6  # Service rate per hour
num_customers <- 1000
num_simulations <- 3

# Function to run a single simulation and return the average wait time
run_simulation <- function() {
  arrival_times <- cumsum(rexp(num_customers, rate=lambda_A))
  service_start_times <- pmax(arrival_times, cummax(arrival_times[-1] + rexp(num_customers-1, rate=lambda_S)))
  service_end_times <- service_start_times + rexp(num_customers, rate=lambda_S)
  wait_times <- service_start_times - arrival_times
  return(mean(wait_times))
}

# Run simulations and calculate average wait times
average_wait_times <- replicate(num_simulations, run_simulation())

# Output average wait times for each run
cat("Average Wait Times for Each Run:", average_wait_times, "\n")



```

The code above attempts to simulate the queueing process of customers at a dining establishment where arrival and service times follow Poisson and exponential distributions, respectively. The system is simulated for 1000 customers, and the simulation is repeated 3 times. For each simulation, arrival times are generated according to a Poisson process, and service times are modeled by an exponential distribution. The simulation calculates the start and end times of each customer's service and computes the wait time for each customer as the difference between their service start time and arrival time. The average wait time for each simulation run is then calculated and displayed.

#### Part Three - The Exponential Simulation accounting for a Que

```{r}


lambda_A <- 5  # Arrival rate per hour
lambda_S <- 6  # Service rate per hour
num_customers <- 1000
num_simulations <- 3

# Function to run a single simulation and return the average wait time
run_simulation <- function() {
  arrival_times <- cumsum(rexp(num_customers, rate=lambda_A))
  service_start_times <- numeric(num_customers)
  service_end_times <- numeric(num_customers)
  
  # Initialize the service times
  service_start_times[1] <- arrival_times[1]
  service_end_times[1] <- service_start_times[1] + rexp(1, rate=lambda_S)
  
  # Calculate service times for each subsequent customer
  for (i in 2:num_customers) {
    service_start_times[i] <- max(arrival_times[i], service_end_times[i-1])
    service_end_times[i] <- service_start_times[i] + rexp(1, rate=lambda_S)
  }
  
  wait_times <- service_start_times - arrival_times
  return(mean(wait_times))
}

# Run simulations and calculate average wait times
average_wait_times <- replicate(num_simulations, run_simulation())

# Output average wait times for each run
cat("Average Wait Times for Each Run:", average_wait_times, "\n")

```

In part two, we attempted to calculate the start time of each customer's service as the maximum of their arrival time or the end time of the previous customer\'s service. Model one did not correctly account for the situation where the first customer\'s service time determines the second customer's potential wait, and it incorrectly handles the alignment of times for all customers. The service rate ,mu, is faster than the arrival rate lambda, which would generally suggest a system that doesn't build up a long queue. However, the theoretical waiting time still suggests a significant wait because, while the queue processes quickly, the relative closeness of the rates means each customer often has to wait for the previous one to finish. By increasing the number of customers and simulations, we got a more accurate representation of the theoretical values, averaging out the anomalies and fluctuations that were do to randomness.  Model two also handled sequential dependency. Each customer's service start time correctly depends on both their arrival time and the exact end time of the previous customer's service. This ensures that the simulation accurately represents a queue where each customer waits if and only if the previous customer has not finished. The loop is also initialized correctly, as it sets up the first customer and then iterates through the rest, ensuring that each customer is handled accurately without index misalignment.

## Discussions & Limitations

## Conclusion
